---
name: Интеграция ЮКассы
overview: "План интеграции платежной системы ЮКасса для обработки оплаты подписок: создание моделей платежей, интеграция API ЮКассы, обработка webhook-уведомлений, обновление логики смены планов с оплатой, создание админ-панели для управления платежами."
todos:
  - id: install-yookassa
    content: "Установить SDK ЮКассы: добавить yookassa в requirements.txt"
    status: pending
  - id: config-yookassa
    content: "Добавить конфигурацию ЮКассы: создать YooKassaConfig в config.py с переменными окружения"
    status: pending
  - id: migration-payments
    content: "Создать миграцию для таблицы payments: все поля для хранения информации о платежах"
    status: pending
  - id: entity-payment
    content: Создать доменную сущность Payment и enums для статусов
    status: pending
  - id: model-payment
    content: Создать SQLAlchemy модель PaymentModel
    status: pending
    dependencies:
      - migration-payments
  - id: repository-payment
    content: Создать интерфейс и реализацию PaymentRepository, добавить в UnitOfWork
    status: pending
    dependencies:
      - model-payment
  - id: client-yookassa
    content: "Создать YooKassaClient для работы с API: создание платежей, получение статуса, возвраты"
    status: pending
    dependencies:
      - config-yookassa
  - id: usecase-create-payment
    content: "Создать CreatePaymentUseCase: создание платежа через ЮКассу и сохранение в БД"
    status: pending
    dependencies:
      - client-yookassa
      - repository-payment
  - id: usecase-process-payment
    content: "Создать ProcessSuccessfulPaymentUseCase: активация подписки после успешной оплаты"
    status: pending
    dependencies:
      - repository-payment
  - id: webhook-endpoint
    content: Создать endpoint POST /api/payments/webhook для обработки уведомлений от ЮКассы
    status: pending
    dependencies:
      - usecase-process-payment
  - id: usecase-update-status
    content: Создать UpdatePaymentStatusUseCase для синхронизации статуса платежа
    status: pending
    dependencies:
      - client-yookassa
      - repository-payment
  - id: payment-worker
    content: Создать payment_status_worker для периодической проверки статуса платежей
    status: pending
    dependencies:
      - usecase-update-status
  - id: update-change-plan
    content: "Обновить endpoint POST /api/subscription/change-plan: создание платежа для платных планов"
    status: pending
    dependencies:
      - usecase-create-payment
  - id: payment-status-endpoint
    content: Создать endpoint GET /api/payments/{payment_id} для проверки статуса платежа
    status: pending
    dependencies:
      - repository-payment
  - id: payment-success-endpoint
    content: Создать endpoint GET /api/payments/success для обработки возврата после оплаты
    status: pending
    dependencies:
      - usecase-process-payment
  - id: frontend-api
    content: "Обновить frontend API клиент: функции для работы с платежами"
    status: pending
  - id: frontend-plans-page
    content: "Обновить PlansPage: обработка создания платежа и редирект на оплату"
    status: pending
    dependencies:
      - frontend-api
  - id: frontend-success-page
    content: Создать PaymentSuccessPage для отображения результата оплаты
    status: pending
    dependencies:
      - frontend-api
  - id: admin-payments-list
    content: Создать endpoint GET /api/admin/payments для списка платежей (только для админов)
    status: pending
    dependencies:
      - repository-payment
  - id: admin-payment-detail
    content: Создать endpoint GET /api/admin/payments/{id} для детальной информации о платеже
    status: pending
    dependencies:
      - repository-payment
  - id: usecase-refund
    content: Создать CreateRefundUseCase для обработки возвратов средств
    status: pending
    dependencies:
      - client-yookassa
      - repository-payment
  - id: admin-refund-endpoint
    content: Создать endpoint POST /api/admin/payments/{id}/refund для возврата средств
    status: pending
    dependencies:
      - usecase-refund
  - id: docs-payments
    content: "Создать документацию docs/payments.md: настройка, использование, troubleshooting"
    status: pending
  - id: logging-payments
    content: Добавить подробное логирование во все use cases и клиенты для платежей
    status: pending
  - id: docs-actualize
    content: "Актуализировать документацию: обновить docs/api/endpoints/payments.md, docs/user-guide/payments.md, docs/reference/environment-variables.md и другие разделы с учетом интеграции ЮКассы"
    status: pending
---

# План интеграции платежной системы ЮКасса

## Обзор требований

На основе ответов на вопросы:

- **Способы оплаты:** Все доступные в ЮКассе (карты, СБП, электронные кошельки)
- **Сценарий оплаты:** Редирект на страницу оплаты ЮКассы
- **Тип подписки:** Одноразовая оплата за период (30 дней), ручное продление
- **Смена плана:** Всегда полная цена нового плана
- **Пробный период:** Не нужен
- **Возвраты:** Ручной возврат через админ-панель
- **Уведомления:** Webhook + резервная проверка через API
- **Тестовый режим:** Нужен для разработки
- **История платежей:** Только для администраторов
- **Чеки:** Отправка на email через ЮКассу

## Фаза 1: Подготовка инфраструктуры и зависимостей

### 1.1 Установка SDK ЮКассы

**Файлы:**

- `backend/requirements.txt`

**Действия:**

1. Добавить зависимость `yookassa>=3.0.0` в requirements.txt
2. Обновить документацию по установке зависимостей

**Логика:** SDK ЮКассы предоставляет удобный интерфейс для работы с API платежей, обработки webhook-уведомлений и создания платежей.

### 1.2 Добавление конфигурации ЮКассы

**Файлы:**

- `backend/config.py`

**Действия:**

1. Создать dataclass `YooKassaConfig` с полями:

- `shop_id` - ID магазина в ЮКассе
- `secret_key` - Секретный ключ для API
- `test_mode` - Флаг тестового режима (True/False)
- `return_url` - URL для возврата после оплаты
- `webhook_url` - URL для получения webhook-уведомлений

2. Добавить в `load_config()` чтение переменных окружения:

- `YOOKASSA_SHOP_ID` - обязательная
- `YOOKASSA_SECRET_KEY` - обязательная
- `YOOKASSA_TEST_MODE` - опциональная, дефолт True для разработки
- `YOOKASSA_RETURN_URL` - опциональная, дефолт `${FRONTEND_URL}/subscription/success`
- `YOOKASSA_WEBHOOK_URL` - опциональная, дефолт `${BACKEND_URL}/api/payments/webhook`

3. Добавить `YooKassaConfig` в `AppConfig`

**Логика:** Централизованная конфигурация позволит легко переключаться между тестовым и продакшн режимами, а также настраивать URL для разных окружений.

## Фаза 2: Создание моделей данных для платежей

### 2.1 Создание миграции для таблицы платежей

**Файлы:**

- `backend/alembic/versions/xxxx_create_payments_table.py`

**Действия:**

1. Создать таблицу `payments` с полями:

- `id` (UUID, primary key)
- `user_id` (UUID, FK на users.id, CASCADE)
- `subscription_plan_id` (UUID, FK на subscription_plans.id, RESTRICT)
- `yookassa_payment_id` (String, уникальный, индекс) - ID платежа в ЮКассе
- `amount` (Numeric(10, 2)) - сумма платежа
- `currency` (String(3), дефолт 'RUB') - валюта
- `status` (String(50), индекс) - статус платежа (pending, succeeded, canceled, waiting_for_capture)
- `payment_method` (String(50), nullable) - способ оплаты
- `description` (Text, nullable) - описание платежа
- `metadata` (JSONB, nullable) - дополнительные данные от ЮКассы
- `created_at` (DateTime, timezone=True)
- `updated_at` (DateTime, timezone=True)
- `paid_at` (DateTime, timezone=True, nullable) - время оплаты
- `expires_at` (DateTime, timezone=True, nullable) - срок действия платежа
- `cancellation_reason` (String(255), nullable) - причина отмены
- `refunded_amount` (Numeric(10, 2), дефолт 0) - сумма возврата
- `is_refunded` (Boolean, дефолт False) - флаг полного возврата

2. Создать индексы:

- На `user_id` для быстрого поиска платежей пользователя
- На `yookassa_payment_id` для поиска по ID ЮКассы
- На `status` для фильтрации по статусу
- Составной индекс на `(user_id, created_at)` для истории платежей

**Логика:** Таблица будет хранить все транзакции, что позволит отслеживать историю платежей, обрабатывать возвраты и анализировать статистику.

### 2.2 Создание доменной сущности Payment

**Файлы:**

- `backend/domain/entities/payment.py`

**Действия:**

1. Создать dataclass `Payment` с полями, соответствующими модели БД
2. Добавить enum `PaymentStatus` для статусов платежа
3. Добавить enum `PaymentMethod` для способов оплаты (опционально)

**Логика:** Доменная сущность обеспечит типобезопасность и централизованное управление бизнес-логикой платежей.

### 2.3 Создание SQLAlchemy модели PaymentModel

**Файлы:**

- `backend/infrastructure/database/models/payment_model.py`

**Действия:**

1. Создать класс `PaymentModel` наследуемый от `Base`
2. Определить все поля согласно миграции
3. Настроить relationships с `UserModel` и `SubscriptionPlanModel`

**Логика:** Модель SQLAlchemy обеспечит маппинг между БД и доменными сущностями.

### 2.4 Создание репозитория для платежей

**Файлы:**

- `backend/domain/interfaces/payment_repository_port.py` - интерфейс
- `backend/infrastructure/database/repositories/payment_repository.py` - реализация

**Действия:**

1. Создать интерфейс `PaymentRepositoryPort` с методами:

- `create(payment: Payment) -> Payment`
- `get_by_id(payment_id: UUID) -> Payment | None`
- `get_by_yookassa_id(yookassa_id: str) -> Payment | None`
- `get_by_user_id(user_id: UUID, limit: int, offset: int) -> list[Payment]`
- `update(payment: Payment) -> Payment`
- `get_by_status(status: PaymentStatus) -> list[Payment]`

2. Реализовать `PaymentRepository` с использованием SQLAlchemy

**Логика:** Репозиторий обеспечит абстракцию доступа к данным и позволит легко тестировать бизнес-логику.

### 2.5 Добавление репозитория в UnitOfWork

**Файлы:**

- `backend/infrastructure/database/unit_of_work.py`
- `backend/domain/interfaces/unit_of_work_port.py`

**Действия:**

1. Добавить `payment_repository` в интерфейс `UnitOfWorkPort`
2. Реализовать lazy initialization в `UnitOfWork`
3. Добавить импорт модели в `alembic/env.py` для автогенерации миграций

**Логика:** Интеграция в UnitOfWork обеспечит транзакционность операций с платежами.

## Фаза 3: Интеграция с API ЮКассы

### 3.1 Создание клиента ЮКассы

**Файлы:**

- `backend/infrastructure/clients/yookassa_client.py`

**Действия:**

1. Создать класс `YooKassaClient` для работы с API ЮКассы
2. Реализовать методы:

- `create_payment(amount: Decimal, currency: str, description: str, metadata: dict, return_url: str) -> dict` - создание платежа
- `get_payment(payment_id: str) -> dict` - получение информации о платеже
- `cancel_payment(payment_id: str) -> dict` - отмена платежа
- `create_refund(payment_id: str, amount: Decimal, description: str) -> dict` - создание возврата

3. Использовать SDK ЮКассы для выполнения запросов
4. Обрабатывать ошибки API и логировать их

**Логика:** Клиент инкапсулирует всю логику взаимодействия с API ЮКассы, что упростит тестирование и поддержку.

### 3.2 Создание интерфейса для клиента ЮКассы

**Файлы:**

- `backend/domain/interfaces/yookassa_client_port.py`

**Действия:**

1. Создать абстрактный интерфейс `YooKassaClientPort` с методами клиента
2. Использовать для dependency injection

**Логика:** Интерфейс позволит легко подменять реализацию для тестирования и обеспечит соблюдение принципа инверсии зависимостей.

### 3.3 Создание use case для создания платежа

**Файлы:**

- `backend/domain/use_cases/create_payment.py`

**Действия:**

1. Создать `CreatePaymentUseCase` с зависимостями:

- `yookassa_client: YooKassaClientPort`
- `payment_repository: PaymentRepositoryPort`
- `subscription_plan_repository: SubscriptionPlanRepositoryPort`

2. Реализовать метод `execute(user_id: UUID, plan_name: str) -> tuple[Payment, str]`:

- Получить план подписки по имени
- Проверить, что план не FREE
- Создать запись платежа в БД со статусом `pending`
- Вызвать API ЮКассы для создания платежа
- Обновить запись платежа с `yookassa_payment_id` и `expires_at`
- Вернуть платеж и URL для редиректа на оплату

**Логика:** Use case инкапсулирует бизнес-логику создания платежа и обеспечит корректную обработку ошибок.

### 3.4 Создание use case для обработки успешного платежа

**Файлы:**

- `backend/domain/use_cases/process_successful_payment.py`

**Действия:**

1. Создать `ProcessSuccessfulPaymentUseCase` с зависимостями:

- `payment_repository: PaymentRepositoryPort`
- `user_subscription_repository: UserSubscriptionRepositoryPort`
- `subscription_plan_repository: SubscriptionPlanRepositoryPort`
- `change_subscription_uc: ChangeUserSubscriptionUseCase`

2. Реализовать метод `execute(payment_id: UUID) -> Payment`:

- Получить платеж по ID
- Проверить, что платеж в статусе `succeeded`
- Проверить, что подписка еще не активирована (защита от повторной обработки)
- Вызвать `ChangeUserSubscriptionUseCase` для активации подписки
- Обновить платеж с временем оплаты
- Вернуть обновленный платеж

**Логика:** Use case обеспечит атомарность операции активации подписки после успешной оплаты.

## Фаза 4: Обработка webhook-уведомлений

### 4.1 Создание роутера для webhook

**Файлы:**

- `backend/presentation/routers/payment_router.py`

**Действия:**

1. Создать роутер с префиксом `/api/payments`
2. Создать endpoint `POST /webhook`:

- Принимать JSON от ЮКассы
- Валидировать подпись уведомления (опционально, для безопасности)
- Извлекать `yookassa_payment_id` из события
- Получать актуальный статус платежа через API ЮКассы
- Обновлять статус платежа в БД
- Если статус `succeeded`, вызывать `ProcessSuccessfulPaymentUseCase`
- Логировать все действия
- Возвращать 200 OK для подтверждения получения

**Логика:** Webhook обеспечит мгновенное обновление статуса платежа без необходимости опроса API.

### 4.2 Создание use case для обновления статуса платежа

**Файлы:**

- `backend/domain/use_cases/update_payment_status.py`

**Действия:**

1. Создать `UpdatePaymentStatusUseCase` с зависимостями:

- `payment_repository: PaymentRepositoryPort`
- `yookassa_client: YooKassaClientPort`

2. Реализовать метод `execute(yookassa_payment_id: str) -> Payment`:

- Получить платеж из БД по `yookassa_payment_id`
- Если платеж не найден, создать новый (на случай, если webhook пришел раньше)
- Получить актуальный статус из API ЮКассы
- Обновить платеж в БД
- Вернуть обновленный платеж

**Логика:** Use case обеспечит синхронизацию статуса платежа между ЮКассой и нашей БД.

### 4.3 Создание воркера для периодической проверки платежей

**Файлы:**

- `backend/workers/payment_status_worker.py`

**Действия:**

1. Создать воркер, который периодически (каждые 5-10 минут):

- Находит платежи в статусе `pending` или `waiting_for_capture`
- Проверяет их статус через API ЮКассы
- Обновляет статус в БД
- Если платеж стал `succeeded`, вызывает `ProcessSuccessfulPaymentUseCase`

2. Добавить воркер в lifecycle FastAPI приложения (как другие воркеры)

**Логика:** Воркер обеспечит резервную проверку статуса платежей на случай, если webhook не придет или будет пропущен.

## Фаза 5: Обновление логики смены плана с оплатой

### 5.1 Обновление эндпоинта смены плана

**Файлы:**

- `backend/presentation/routers/subscription_router.py`

**Действия:**

1. Обновить endpoint `POST /change-plan`:

- Если план FREE - сразу активировать (как сейчас)
- Если план платный:
- Проверить, что пользователь не является админом (для админов оставить старую логику)
- Создать платеж через `CreatePaymentUseCase`
- Вернуть ответ с URL для редиректа на оплату

2. Создать новый DTO `CreatePaymentResponse` с полем `payment_url`

**Логика:** Эндпоинт будет создавать платеж вместо мгновенной активации подписки для платных планов.

### 5.2 Создание эндпоинта для проверки статуса платежа

**Файлы:**

- `backend/presentation/routers/payment_router.py`

**Действия:**

1. Создать endpoint `GET /payment/{payment_id}`:

- Проверять, что платеж принадлежит текущему пользователю
- Возвращать статус платежа и информацию о подписке

**Логика:** Эндпоинт позволит фронтенду проверять статус платежа после возврата с страницы оплаты.

### 5.3 Создание эндпоинта для страницы успешной оплаты

**Файлы:**

- `backend/presentation/routers/payment_router.py`

**Действия:**

1. Создать endpoint `GET /payment/success`:

- Принимать query параметр `payment_id` от ЮКассы
- Проверять статус платежа
- Если платеж успешен, возвращать информацию о подписке
- Если платеж еще в процессе, возвращать статус "ожидание"

**Логика:** Эндпоинт обработает возврат пользователя после оплаты и покажет результат.

## Фаза 6: Обновление фронтенда

### 6.1 Обновление API клиента

**Файлы:**

- `frontend/src/api/subscription.ts`

**Действия:**

1. Обновить функцию `changePlan`:

- Обрабатывать ответ с `payment_url`
- Редиректить пользователя на URL оплаты

2. Добавить функции:

- `getPaymentStatus(paymentId: string)` - проверка статуса платежа
- `checkPaymentSuccess(paymentId: string)` - проверка успешности оплаты

**Логика:** API клиент обеспечит взаимодействие фронтенда с новыми эндпоинтами оплаты.

### 6.2 Обновление страницы планов

**Файлы:**

- `frontend/src/pages/PlansPage.tsx`

**Действия:**

1. Обновить обработчик `handleChangePlan`:

- Если план FREE - вызывать старую логику
- Если план платный:
- Вызывать API для создания платежа
- Редиректить на URL оплаты

2. Добавить обработку возврата с оплаты:

- Проверять query параметры после возврата
- Показывать сообщение об успешной оплате или ошибке

**Логика:** Страница планов будет корректно обрабатывать процесс оплаты и редирект на страницу ЮКассы.

### 6.3 Создание страницы успешной оплаты

**Файлы:**

- `frontend/src/pages/PaymentSuccessPage.tsx`

**Действия:**

1. Создать страницу для отображения результата оплаты:

- Проверять статус платежа через API
- Показывать сообщение об успехе или ошибке
- Предлагать перейти в личный кабинет
- Обрабатывать случаи, когда платеж еще обрабатывается

**Логика:** Страница обеспечит понятную обратную связь пользователю после оплаты.

## Фаза 7: Админ-панель для управления платежами

### 7.1 Создание эндпоинтов для админов

**Файлы:**

- `backend/presentation/routers/payment_router.py`

**Действия:**

1. Создать endpoint `GET /admin/payments`:

- Только для суперпользователей
- Возвращать список всех платежей с пагинацией
- Поддерживать фильтрацию по статусу, пользователю, дате

2. Создать endpoint `GET /admin/payments/{payment_id}`:

- Детальная информация о платеже

3. Создать endpoint `POST /admin/payments/{payment_id}/refund`:

- Создание возврата через API ЮКассы
- Обновление статуса платежа в БД

**Логика:** Эндпоинты обеспечат администраторам возможность управления платежами и обработки возвратов.

### 7.2 Создание DTO для админ-панели

**Файлы:**

- `backend/presentation/dto/payment_response.py`

**Действия:**

1. Создать DTO:

- `PaymentResponse` - информация о платеже
- `PaymentsListResponse` - список платежей с пагинацией
- `RefundRequest` - запрос на возврат

**Логика:** DTO обеспечат типобезопасность и валидацию данных для админ-панели.

### 7.3 Создание use case для возврата

**Файлы:**

- `backend/domain/use_cases/create_refund.py`

**Действия:**

1. Создать `CreateRefundUseCase` с зависимостями:

- `yookassa_client: YooKassaClientPort`
- `payment_repository: PaymentRepositoryPort`
- `user_subscription_repository: UserSubscriptionRepositoryPort`

2. Реализовать метод `execute(payment_id: UUID, amount: Decimal | None, reason: str) -> Payment`:

- Получить платеж по ID
- Проверить, что платеж успешен и не был возвращен
- Если amount не указан, вернуть полную сумму
- Вызвать API ЮКассы для создания возврата
- Обновить платеж в БД (установить `is_refunded` или обновить `refunded_amount`)
- Опционально: отменить подписку пользователя (перевести на FREE)

**Логика:** Use case обеспечит корректную обработку возвратов с проверкой всех условий.

## Фаза 8: Тестирование и документация

### 8.1 Настройка тестового режима

**Действия:**

1. Создать инструкцию по настройке тестового аккаунта ЮКассы
2. Документировать тестовые карты для проверки разных сценариев
3. Настроить переменные окружения для тестового режима

**Логика:** Тестовый режим позволит безопасно разрабатывать и тестировать интеграцию без реальных платежей.

### 8.2 Создание документации

**Файлы:**

- `docs/payments.md`

**Действия:**

1. Документировать:

- Процесс настройки ЮКассы
- Настройку webhook URL в личном кабинете ЮКассы
- Процесс создания платежа
- Обработку webhook-уведомлений
- Процесс возврата средств
- Troubleshooting

**Логика:** Документация упростит поддержку и развертывание системы платежей.

### 8.3 Добавление логирования

**Действия:**

1. Добавить подробное логирование во все use cases и клиенты:

- Создание платежей
- Обновление статусов
- Обработка webhook
- Возвраты

2. Логировать все ошибки с контекстом

**Логика:** Логирование поможет быстро находить и исправлять проблемы в продакшене.

## Порядок выполнения

1. **Фаза 1** - Подготовка (зависимости и конфигурация)
2. **Фаза 2** - Модели данных (миграции, сущности, репозитории)
3. **Фаза 3** - Интеграция с API (клиент, use cases)
4. **Фаза 4** - Webhook и воркер
5. **Фаза 5** - Обновление логики подписок
6. **Фаза 6** - Фронтенд
7. **Фаза 7** - Админ-панель
8. **Фаза 8** - Тестирование и документация

После каждой фазы необходимо тестировать функциональность и убеждаться, что ничего не сломалось.

## Фаза 9: Актуализация документации

### 9.1 Обновление API документации

**Файлы:**

- `docs/api/endpoints/payments.md`

**Действия:**

1. Документировать все новые эндпоинты:

- `POST /api/payments/webhook` - обработка webhook от ЮКассы
- `GET /api/payments/{payment_id}` - проверка статуса платежа
- `GET /api/payments/success` - страница успешной оплаты
- `GET /api/admin/payments` - список платежей для админов
- `GET /api/admin/payments/{id}` - детали платежа
- `POST /api/admin/payments/{id}/refund` - возврат средств

2. Добавить примеры запросов и ответов
3. Описать обработку ошибок

**Логика:** Документация API поможет разработчикам фронтенда и другим интеграторам правильно использовать эндпоинты.

### 9.2 Обновление руководства пользователя

**Файлы:**

- `docs/user-guide/payments.md`

**Действия:**

1. Обновить инструкции по оплате подписки:

- Процесс выбора плана
- Редирект на страницу оплаты ЮКассы
- Обработка возврата после оплаты
- Проверка статуса платежа

2. Добавить информацию о способах оплаты
3. Описать процесс возврата средств (для пользователей)

**Логика:** Пользователи должны понимать, как работает процесс оплаты.

### 9.3 Обновление справочной информации

**Файлы:**

- `docs/reference/environment-variables.md`

**Действия:**

1. Добавить новые переменные окружения:

- `YOOKASSA_SHOP_ID`
- `YOOKASSA_SECRET_KEY`
- `YOOKASSA_TEST_MODE`
- `YOOKASSA_RETURN_URL`
- `YOOKASSA_WEBHOOK_URL`

2. Описать назначение каждой переменной
3. Указать значения по умолчанию

**Логика:** Разработчики должны знать, какие переменные окружения нужны для работы платежной системы.

### 9.4 Обновление архитектурной документации

**Файлы:**

- `docs/architecture/domain-model.md`
- `docs/components/README.md`

**Действия:**

1. Добавить описание доменной сущности `Payment` в `docs/architecture/domain-model.md`
2. Обновить `docs/components/README.md` с информацией о платежной системе
3. Описать взаимодействие компонентов при обработке платежей

**Логика:** Архитектурная документация должна отражать все компоненты системы, включая платежи.

### 9.5 Обновление troubleshooting

**Файлы:**

- `docs/troubleshooting/common-issues.md`
- `docs/troubleshooting/api-issues.md`

**Действия:**

1. Добавить раздел о проблемах с платежами:

- Платеж не создается
- Webhook не приходит
- Платеж не обрабатывается
- Проблемы с возвратом

2. Описать решения типичных проблем

**Логика:** Troubleshooting поможет быстро решать проблемы с платежами в продакшене.