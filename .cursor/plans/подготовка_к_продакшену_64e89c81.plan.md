---
name: Подготовка к продакшену
overview: "План подготовки проекта к запуску в продакшене: устранение критичных проблем безопасности, настройка конфигурации, оптимизация инфраструктуры и создание необходимой документации."
todos:
  - id: security-jwt-secrets
    content: "Вынести JWT секреты в конфигурацию: добавить AuthConfig в config.py, обновить fastapi_users_setup.py и hh_auth_router.py"
    status: pending
  - id: security-cors
    content: "Настроить CORS для продакшена: добавить cors_origins в конфиг, обновить app.py"
    status: pending
  - id: security-docker-secrets
    content: Удалить хардкоженные секреты из docker-compose.yml, оставить только переменные окружения
    status: pending
  - id: security-env-example
    content: Создать .env.example файл со всеми переменными окружения и описаниями
    status: pending
  - id: config-nginx
    content: "Настроить nginx для продакшена: добавить поддержку переменных для server_name, подготовить SSL конфигурацию"
    status: pending
  - id: config-frontend-url
    content: "Обновить FRONTEND_URL для продакшена: убрать дефолты, добавить валидацию"
    status: pending
  - id: config-debug-logs
    content: Удалить хардкоженные пути к debug логам, использовать переменные окружения
    status: pending
  - id: config-environment
    content: Добавить переменную ENVIRONMENT в конфигурацию для разделения dev/prod логики
    status: pending
  - id: infra-uvicorn
    content: "Настроить production режим для uvicorn: добавить workers, оптимизировать настройки"
    status: pending
  - id: infra-healthcheck
    content: Добавить healthcheck для backend сервиса в docker-compose.yml
    status: pending
  - id: infra-dockerfile
    content: "Оптимизировать Dockerfile для продакшена: multi-stage builds, уменьшение размера"
    status: pending
  - id: infra-logging
    content: "Настроить логирование для продакшена: централизованная конфигурация, уровни логов"
    status: pending
  - id: docs-deployment
    content: "Создать документацию по деплою: docs/deployment.md с инструкциями"
    status: pending
  - id: docs-readme
    content: Обновить README с информацией о production deployment
    status: pending
  - id: scripts-secrets
    content: "Создать скрипт генерации секретов: scripts/generate-secrets.sh"
    status: pending
  - id: docs-actualize
    content: "Актуализировать документацию: обновить все разделы docs/ с учетом изменений в конфигурации, безопасности, деплое и инфраструктуре"
    status: pending
---

# План подготовки проекта к продакшену

## Фаза 1: Критичные проблемы безопасности (блокирующие запуск)

### 1.1 Вынос JWT секретов в конфигурацию

**Проблема:** В коде захардкожены секреты "SECRET" для JWT токенов в трех местах:

- `backend/infrastructure/auth/fastapi_users_setup.py` (строки 35, 36, 110)
- `backend/presentation/routers/hh_auth_router.py` (строка 158)

**Решение:**

1. Добавить в `backend/config.py` новую секцию `AuthConfig` с полями:

- `jwt_secret` - секретный ключ для JWT токенов
- `jwt_lifetime_seconds` - время жизни токена (по умолчанию 7200000)
- `reset_password_token_secret` - секрет для токенов сброса пароля
- `verification_token_secret` - секрет для токенов верификации

2. В `load_config()` добавить чтение переменных окружения:

- `JWT_SECRET` - обязательная переменная, без дефолта
- `JWT_LIFETIME_SECONDS` - опциональная, дефолт 7200000
- `RESET_PASSWORD_TOKEN_SECRET` - опциональная, можно использовать тот же JWT_SECRET
- `VERIFICATION_TOKEN_SECRET` - опциональная, можно использовать тот же JWT_SECRET

3. Обновить `AppConfig` для включения `AuthConfig`

4. В `fastapi_users_setup.py`:

- Изменить `UserManager.reset_password_token_secret` и `verification_token_secret` на чтение из конфига
- Обновить `get_jwt_strategy()` для использования `config.auth.jwt_secret` и `config.auth.jwt_lifetime_seconds`

5. В `hh_auth_router.py`:

- Обновить `_get_jwt_strategy()` для использования тех же значений из конфига

**Логика:** Все секреты будут читаться из переменных окружения через единую точку конфигурации, что обеспечит безопасность и централизованное управление.

### 1.2 Настройка CORS для продакшена

**Проблема:** В `backend/presentation/app.py` (строка 128) CORS настроен на `allow_origins=["*"]`, что небезопасно для продакшена.

**Решение:**

1. Добавить в `backend/config.py` поле `cors_origins` в конфигурацию приложения
2. Читать из переменной окружения `CORS_ORIGINS` (список через запятую)
3. В `app.py` заменить `allow_origins=["*"] `на `allow_origins=config.cors_origins.split(",")`
4. Для разработки можно оставить возможность использовать "*" через переменную `CORS_ALLOW_ALL=true`

**Логика:** CORS будет ограничен только разрешенными доменами, что предотвратит CSRF атаки.

### 1.3 Удаление хардкоженных секретов из docker-compose.yml

**Проблема:** В `docker-compose.yml` захардкожены токены и ключи (строки 33, 37).

**Решение:**

1. Удалить все дефолтные значения для секретных переменных (OPENAI_API_KEY, TELEGRAM_BOT_TOKEN)
2. Оставить только переменные окружения без дефолтов: `${OPENAI_API_KEY}`, `${TELEGRAM_BOT_TOKEN}`
3. Все секреты должны быть в `.env` файле, который не коммитится

**Логика:** Секреты не будут храниться в репозитории, что соответствует best practices безопасности.

### 1.4 Создание .env.example файла

**Проблема:** Отсутствует шаблон переменных окружения для разработчиков.

**Решение:**

1. Создать `.env.example` в корне проекта
2. Включить все переменные окружения с описаниями:

- Секреты с примерами формата (например, `JWT_SECRET=your-secret-key-here`)
- Конфигурационные переменные с дефолтными значениями
- Комментарии с описанием назначения каждой переменной

3. Добавить инструкцию по генерации секретов (например, через `openssl rand -hex 32`)

**Логика:** Разработчики смогут быстро настроить окружение, копируя `.env.example` в `.env` и заполняя реальные значения.

## Фаза 2: Конфигурация для продакшена

### 2.1 Настройка nginx для продакшена

**Проблема:** В `frontend/nginx.conf` `server_name` установлен на `localhost` (строка 3).

**Решение:**

1. Добавить переменную окружения `NGINX_SERVER_NAME` в Dockerfile фронтенда
2. Использовать envsubst в nginx.conf для подстановки значения
3. Или создать отдельный `nginx.prod.conf` с настройками для продакшена
4. Добавить SSL конфигурацию (пока закомментированную, для настройки после получения сертификатов)
5. Настроить rate limiting для защиты от DDoS

**Логика:** Nginx будет корректно работать с реальным доменом и готов к настройке SSL.

### 2.2 Обновление FRONTEND_URL для продакшена

**Проблема:** В `backend/config.py` и `docker-compose.yml` дефолтное значение `FRONTEND_URL` - `http://localhost:5173`.

**Решение:**

1. В `docker-compose.yml` убрать дефолтное значение, оставить только `${FRONTEND_URL}`
2. В `backend/config.py` оставить дефолт для разработки, но добавить валидацию для продакшена
3. Добавить проверку, что FRONTEND_URL не содержит localhost в продакшене (через переменную `ENVIRONMENT=production`)

**Логика:** Приложение будет использовать правильный URL фронтенда в зависимости от окружения.

### 2.3 Удаление хардкоженных путей к debug логам

**Проблема:** В `backend/presentation/routers/hh_auth_router.py` (строка 180) хардкожен путь `/Users/apple/dev/hh/.cursor/debug.log`.

**Решение:**

1. Добавить переменную окружения `DEBUG_LOG_PATH` (опциональная)
2. Если переменная не задана, отключать debug логирование
3. Использовать относительный путь от корня проекта или абсолютный путь из переменной окружения
4. Добавить проверку на существование директории перед записью

**Логика:** Debug логирование будет работать только в development режиме и не будет ломаться в продакшене.

### 2.4 Добавление переменной ENVIRONMENT

**Решение:**

1. Добавить в `backend/config.py` поле `environment` (development/production)
2. Читать из переменной `ENVIRONMENT` (дефолт "development")
3. Использовать для условной логики (например, отключение debug логов в production)

**Логика:** Приложение будет знать свое окружение и вести себя соответственно.

## Фаза 3: Инфраструктура и оптимизация

### 3.1 Настройка production режима для uvicorn

**Проблема:** В `docker-compose.yml` (строка 60) uvicorn запускается в одном процессе без оптимизаций.

**Решение:**

1. Добавить переменную окружения `UVICORN_WORKERS` (дефолт 1 для разработки, 4 для продакшена)
2. Обновить команду запуска в docker-compose.yml:

- Если workers > 1, использовать `uvicorn ... --workers ${UVICORN_WORKERS}`
- Или использовать gunicorn с uvicorn workers для лучшей производительности

3. Добавить настройки для production: `--no-access-log` (логи через loguru), `--log-level warning`

**Логика:** Приложение будет использовать несколько воркеров для обработки запросов, что увеличит производительность.

### 3.2 Добавление healthcheck для backend

**Решение:**

1. В `docker-compose.yml` добавить healthcheck для сервиса backend:

- Использовать endpoint `/health`
- Интервал проверки 30 секунд
- Таймаут 10 секунд
- 3 попытки перед пометкой как unhealthy

**Логика:** Docker будет знать, когда backend готов к работе, и сможет автоматически перезапускать при сбоях.

### 3.3 Оптимизация Dockerfile для продакшена

**Решение:**

1. В `backend/Dockerfile`:

- Использовать multi-stage build для уменьшения размера образа
- Копировать только необходимые файлы (не весь код в dev режиме)
- Оптимизировать слои кэширования

2. В `frontend/Dockerfile`:

- Убедиться, что используется production build
- Минимизировать размер nginx образа

**Логика:** Образы будут меньше и быстрее собираться, что ускорит деплой.

### 3.4 Настройка логирования для продакшена

**Решение:**

1. Добавить централизованную настройку логирования в `backend/presentation/app.py`
2. Использовать переменную `LOG_LEVEL` (INFO для production, DEBUG для development)
3. Настроить ротацию логов через loguru
4. Добавить возможность отправки логов в внешний сервис (опционально, через переменную `LOG_SERVICE_URL`)

**Логика:** Логи будут структурированы и готовы к централизованному сбору.

## Фаза 4: Документация и финальные настройки

### 4.1 Создание документации по деплою

**Решение:**

1. Создать `docs/deployment.md` с инструкциями:

- Требования к серверу
- Установка Docker и Docker Compose
- Настройка переменных окружения
- Генерация секретов
- Запуск миграций
- Настройка SSL сертификатов
- Процедуры деплоя и отката
- Troubleshooting

**Логика:** Документация позволит быстро развернуть проект на новом сервере.

### 4.2 Обновление README

**Решение:**

1. Добавить секцию "Production Deployment" в основной README
2. Описать процесс генерации секретов
3. Добавить ссылки на документацию по деплою

**Логика:** Разработчики быстро найдут информацию о деплое.

### 4.3 Создание скрипта генерации секретов

**Решение:**

1. Создать `scripts/generate-secrets.sh`:

- Генерация JWT_SECRET через openssl
- Генерация других секретов при необходимости
- Вывод инструкций по добавлению в .env

**Логика:** Автоматизация снизит риск ошибок при настройке секретов.

## Порядок выполнения

1. **Критично (сначала):** Фаза 1 - все пункты безопасности
2. **Важно:** Фаза 2 - конфигурация для продакшена
3. **Оптимизация:** Фаза 3 - инфраструктура
4. **Документация:** Фаза 4 - финальные настройки

После выполнения каждой фазы необходимо протестировать запуск приложения и убедиться, что ничего не сломалось.

## Фаза 5: Актуализация документации

### 5.1 Обновление всей документации

**Действия:**

1. Обновить `docs/deployment/` с учетом всех изменений:

- Новые переменные окружения в `docs/reference/environment-variables.md`
- Обновленные инструкции по деплою в `docs/deployment/docker-deployment.md`
- Настройка безопасности в `docs/deployment/environment-setup.md`

2. Обновить `docs/architecture/`:

- Изменения в конфигурации в `docs/architecture/patterns.md`
- Обновления в структуре проекта

3. Обновить `docs/development/`:

- Новые требования к окружению в `docs/development/development-setup.md`
- Изменения в процессе разработки

4. Обновить `docs/troubleshooting/`:

- Новые проблемы и решения
- Проблемы с конфигурацией и секретами

5. Проверить все ссылки и примеры в документации на актуальность

**Логика:** Документация должна всегда отражать текущее состояние проекта и помогать разработчикам быстро разобраться в изменениях.